<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="www.dream.bullitine_Board.mapper.PostMapper">
	<!-- resultMap : PROJECTION 결과를 객체 속성에 바인딩. -->
	<resultMap id="rmReplyVO" extends="nsEntity.rmMasterEntity"
		type="www.dream.bullitine_Board.model.ReplyVO">
		<result property="content" column="content" />
		<result property="hTier" column="h_tier" />
		<!-- association : 복잡한 타입의 연관관계. 많은 결과는 타입으로 나타난다. 1:1 관계에서 사용한다고 생각하기. 
						   One 2 One 관계까지 속성에 한번에 넣기. 예 : 계시글의 작성자 누구? -->
		
		<!-- columnPrefix("w_"값이 있으면, 위에서 해석하지 말고 가져와서 여기서 해석한다.
						 COLUMN 이름 중첩 시 그 해결방안. 예 : 같은 부분(정모24, 정모55 같은 경우, 정모는 생략)  -->
		<!-- notNullColumn="id" (Null 처리 된 id는 표시하지마세요.)
						 정보가 있어야 객체를 만들지요.(정보 없으면 안함) :  -->
		
		<association property="writer" columnPrefix="w_" notNullColumn="id"
			resultMap="www.dream.bullitine_Board.mapper.PartyMapper.rmPartyVO" />
		<discriminator javaType="String" column="descrim">
			<case value="post" resultMap="rmPostVO" />
		</discriminator>
	</resultMap>
	
	<resultMap id="rmPostVO" extends="rmReplyVO"
		type="www.dream.bullitine_Board.model.PostVO">
		<result property="title" column="TITLE" />
		<result property="readCnt" column="read_cnt" />
		<result property="likeCnt" column="like_cnt" />
		<result property="dislikeCnt" column="dislike_cnt" />
	</resultMap>
	
	<!--  public List<PostVO> listAllPost(String boardId); -->
	<select id="listAllPost" resultMap="rmPostVO">
	
	<!-- ALIAS 에일리어스 -->
	select p.*, w.id w_id, w.descrim w_descrim, w.name w_name, w.gender w_gender, w.reg_dt w_reg_dt, w.upt_dt w_upt_dt
	  from T_reply p LEFT OUTER JOIN T_party w
	  	ON p.writer_id = w.id
	 where p.bb_id = #{boardId}
	 </select>
	 
	<!-- public List<ReplyVO> findById(String id); -->
	<select id="findById" resultMap="rmPostVO">
	select r.*, w.id w_id, w.descrim w_descrim, w.name w_name, w.gender w_gender, w.reg_dt w_reg_dt, w.upt_dt w_upt_dt
	  from T_reply r LEFT OUTER JOIN T_party w
	  	ON r.writer_id = w.id
	 where r.id like CONCAT(#{id}, '%');
	
	
<!-- select p.*, r1, r2, r3		//이렇게 안한다.
	   from T_reply p, T_reply r1, T_reply r2, T_reply r3, _reply r3
	  where r.hid like CONCAT(#{hid}, '_%')   -->
	
	 </select>
	 <!-- h.comp_Hierarchy like CONCAT(mariadb용)(#{id} + '%') = id로 부터 시작하는 모든 댓글들 -->
	 <!-- h.kind = 't2b' = 위에서 아래로 읽는 식(댓글) -->
	 <!-- h.comp_Hierarchy like CONCAT('%', r.id) = 댓글, 대댓글 찾는것. -->
	 
	<!-- public int createPost(PostVO post); -->
	<insert id="createPost">
		<selectKey keyProperty="id" resultType="String" order="BEFORE">
			select NEXT_PK('s_reply')
		</selectKey>
			INSERT INTO T_reply(id, h_tier, descrim, writer_id, content, bb_id, TITLE)
			VALUES (#{id}, 0, 'Post', #{writer.id}, #{content}, #{boardVO.id}, #{title});
	 </insert>
	 
	<!-- public int createReply(@Param("parent") ReplyVO parent, @Param("reply") ReplyVO reply); -->
	<insert id="createReply">
		<selectKey keyProperty="id" resultType="String" order="BEFORE">
			select NEXT_PK('s_reply');
		</selectKey>
			INSERT INTO T_reply(id, h_tier, descrim, writer_id, content);
			VALUES (CONCAT(#{parent.id}, #{id}), #{parent.hierarchyId} + 1, 'reply', #{reply.writer.id}, #{reply.content});
	 </insert>

	<!-- public int updatePost(PostVO post); -->
	<update id="updatePost">
	 update T_reply
		set TITLE = #{title};
			content = #{content};
	  where id = #{id};
	 </update>
	
	<!-- public int updateReply(ReplyVO reply); -->
	<update id="updateReply">
	 update T_reply
		set content = #{content};
	  where id = #{id};
	 </update>
	
	<!-- public int deleteReply(String id); -->
	<delete id="deleteReply">
	 delete T_reply
	  where id = #{id};
	 delete CONCAT(#{id}, '%')
	 </delete>
</mapper>
